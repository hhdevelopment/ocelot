/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package org.ocelotds.processors;

import org.ocelotds.processors.visitors.DataServiceVisitorJsBuilder;
import java.io.File;
import org.ocelotds.annotations.DataService;
import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementVisitor;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import org.ocelotds.Constants;
import org.ocelotds.FileWriterServices;
import org.ocelotds.annotations.JsCacheRemove;
import org.ocelotds.annotations.JsCacheRemoves;
import org.ocelotds.frameworks.NoFwk;
import org.ocelotds.frameworks.angularjs.AngularFwk;
import org.ocelotds.processors.visitors.JsCacheRemoveVisitor;

/**
 * Processor of annotation org.ocelotds.annotations.DataService
 *
 * @author hhfrancois
 */
@SupportedAnnotationTypes(value = {ProcessorConstants.DATASERVICE_AT, ProcessorConstants.JSCACHERMS_AT, ProcessorConstants.JSCACHERM_AT})
@SupportedSourceVersion(SourceVersion.RELEASE_7)
@SupportedOptions({ProcessorConstants.DIRECTORY, ProcessorConstants.FRAMEWORK})
public class OcelotProcessor extends AbstractProcessor {

	private static boolean done = false;

	static boolean isDone() {
		return done;
	}

	static void setDone(boolean done) {
		OcelotProcessor.done = done;
	}

	/**
	 * Tools for access filesystem
	 */
	private Filer filer;

	/**
	 * Tools for log processor
	 */
	private Messager messager;

	/**
	 * Directory where save js stub
	 */
	String jsdir = null;
	/**
	 * jsfwk : null|'ng'
	 */
	String jsfwk = null;

	ElementVisitor visitorfwk;
	ElementVisitor visitorNgfwk;
	ElementVisitor visitorNofwk;
	FileWriterServices fws;

	/**
	 * Init processor<br>
	 * get filer, messager<br>
	 * get options
	 *
	 */
	@Override
	public void init(ProcessingEnvironment processingEnv) {
		super.init(processingEnv);
		messager = processingEnv.getMessager();
		filer = processingEnv.getFiler();
		fws = new FileWriterServices(messager, filer);

		jsdir = getJsDirectory(processingEnv.getOptions());
		jsfwk = getJsFramework(processingEnv.getOptions());

		initVisitors(jsfwk);
	}
	
	void initVisitors(String fwk) {
		visitorNofwk = new DataServiceVisitorJsBuilder(processingEnv, new NoFwk());
		visitorNgfwk = new DataServiceVisitorJsBuilder(processingEnv, new AngularFwk());
		visitorfwk = visitorNofwk;
		if ("ng".equals(fwk)) {
			visitorfwk = visitorNgfwk;
		}
	}

	/**
	 * Get optional output directory
	 *
	 * @param options
	 * @return
	 */
	String getJsFramework(Map<String, String> options) {
		if (null != options) {
			if (options.containsKey(ProcessorConstants.FRAMEWORK)) {
				return options.get(ProcessorConstants.FRAMEWORK);
			}
		}
		return null;
	}

	/**
	 * Get optional output directory
	 *
	 * @param options
	 * @return
	 */
	String getJsDirectory(Map<String, String> options) {
		if (null != options) {
			if (options.containsKey(ProcessorConstants.DIRECTORY)) {
				return options.get(ProcessorConstants.DIRECTORY);
			}
		}
		return null;
	}

	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		// check if process was done on previous round
		if (OcelotProcessor.isDone() || roundEnv.processingOver()) { // Returns true if types generated by this round will not be subject to a subsequent round of annotation processing; returns false otherwise.
			return true; //if is it : stop
		}
		writeCoreInClassesOutput();
		writeCoreInDirectory(jsdir, jsfwk); // one core.js in same time
		for (Element element : roundEnv.getElementsAnnotatedWith(DataService.class)) {
			processElement(element);
		}
		ElementVisitor visitor = new JsCacheRemoveVisitor(processingEnv);
		Set<TypeElement> elements = getTypeElementContainsJsRemoveAnno(roundEnv);
		for (TypeElement te : elements) {
			createPropertiesFile(te, visitor);
		}
		OcelotProcessor.setDone(true);
		return true;
	}
	
	void createPropertiesFile(TypeElement te, ElementVisitor visitor) {
		try (Writer w = fws.getFileObjectWriterInClassOutput(getPackagePath(te), te.getSimpleName().toString()+".properties")) {
			te.accept(visitor, w);
		} catch(IOException ioe) {
			messager.printMessage(Diagnostic.Kind.ERROR, " properties generation class : " + te);
		}
	}
	
	Set<TypeElement> getTypeElementContainsJsRemoveAnno(RoundEnvironment roundEnv) {
		Set<TypeElement> elements = new HashSet<>();
		for (Element element : roundEnv.getElementsAnnotatedWith(JsCacheRemove.class)) {
			if(ExecutableElement.class.isInstance(element)) {
				TypeElement te = (TypeElement) ((ExecutableElement) element).getEnclosingElement();
				elements.add(te);
			}
		}
		for (Element element : roundEnv.getElementsAnnotatedWith(JsCacheRemoves.class)) {
			if(ExecutableElement.class.isInstance(element)) {
				TypeElement te = (TypeElement) ((ExecutableElement) element).getEnclosingElement();
				elements.add(te);
			}
		}
		return elements;
	}

	/**
	 * Process element, filter TypeElement only
	 *
	 * @param element
	 */
	public void processElement(Element element) {
		if (TypeElement.class.isInstance(element)) {
			writeGeneratedJsInDiferentTargets((TypeElement) element);
		}
	}

	/**
	 * Write generated js service in differents target alway in Service class directory, for no framework eg : org.ocelotds.OcelotServies.js </br>
	 * if jsfwk is defined by user, copy fwk version in class directory eg : org.ocelotds.OcelotServies.ng.js </br>
	 * if jsdir is defined by user, copy normal version or fwk version injsdir eg : org.ocelotds.OcelotServies.js or org.ocelotds.OcelotServies.ng.js
	 *
	 * @param element
	 */
	void writeGeneratedJsInDiferentTargets(TypeElement element) {
		String packagePath = getPackagePath(element);
		messager.printMessage(Diagnostic.Kind.MANDATORY_WARNING, " javascript generation class : " + element);
		writeJsFileToJsDir(element, visitorfwk, packagePath, getFilename(element, jsfwk), jsdir); // one core.js in same time
		writeJsFile(element, visitorNgfwk, packagePath, getFilename(element, "ng"));
		writeJsFile(element, visitorNofwk, packagePath, getFilename(element, null));
	}

	/**
	 * generate js service in packagePath.fn in classes directory/packagePath
	 *
	 * @param element
	 * @param visitor
	 * @param packagePath
	 * @param fn
	 */
	void writeJsFile(TypeElement element, ElementVisitor visitor, String packagePath, String fn) {
		try (Writer w = fws.getFileObjectWriterInClassOutput(packagePath, fn)) {
			element.accept(visitor, w);
		} catch (IOException ioe) {
			messager.printMessage(Diagnostic.Kind.MANDATORY_WARNING, " FAILED TO CREATE : " + packagePath + "." + fn);
		}
	}

	/**
	 * generate js service in packagePath.fn in classes directory/packagePath
	 *
	 * @param element
	 * @param visitor
	 * @param packagePath
	 * @param fn
	 */
	void writeJsFileToJsDir(TypeElement element, ElementVisitor visitor, String packagePath, String fn, String dir) {
		if (null != dir) {
			try (Writer w = fws.getFileObjectWriter(dir + File.separatorChar + "srvs", packagePath + "." + fn)) {
				messager.printMessage(Diagnostic.Kind.MANDATORY_WARNING, " javascript generation class : " + element + " to : " + dir);
				element.accept(visitor, w);
			} catch (IOException ioe) {
				messager.printMessage(Diagnostic.Kind.MANDATORY_WARNING, " FAILED TO CREATE : " + packagePath + "." + fn);
			}
		}
	}

	/**
	 * Get pachage name of class
	 *
	 * @param te
	 * @return
	 */
	String getPackagePath(TypeElement te) {
		return te.getQualifiedName().toString().replaceAll("." + te.getSimpleName(), "");
	}

	/**
	 * Get Js filename from class
	 *
	 * @param te
	 * @return
	 */
	String getFilename(TypeElement te, String fwk) {
		return getFilename(te.getSimpleName().toString(), fwk);
	}

	String getFilename(String withoutext, String fwk) {
		if (null != fwk) {
			return withoutext + "." + fwk + Constants.JS;
		}
		return withoutext + Constants.JS;
	}

	/**
	 * Write core in user directory (use jsdir option) select the core for framework define by the user by jsfwk option
	 */
	void writeCoreInDirectory(String dir, String fwk) {
		if (dir != null) { // if developper specify a directory for get js we write them too inside jsdir 
			fws.copyResourceToDir(ProcessorConstants.SEPARATORCHAR + "js", getFilename("core", fwk), dir);
		}
	}

	/**
	 * Write core in classes directory
	 */
	void writeCoreInClassesOutput() {
		String resPath = ProcessorConstants.SEPARATORCHAR + "js";
		fws.copyResourceToClassesOutput(resPath, "core.ng.min.js");
		fws.copyResourceToClassesOutput(resPath, "core.ng.js");
		fws.copyResourceToClassesOutput(resPath, "core.min.js");
		fws.copyResourceToClassesOutput(resPath, "core.js");
	}
}
